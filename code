pragma solidity =0.6.0;

contract Registration{
    
    address owner;

    struct manufacturer {
        string name;
        string adress;
        bool existManufacturer;
    }
    struct distributor {
        string name;
        string adress;
        bool existDistributor;
    }
    struct wholesaler {
        string name;
        string adress;
        bool existWholesaler;
    }

    struct provider {
        string name;
        string adress;
        bool existProvider;
    }
    
    
    mapping(address=>manufacturer) manufacturers;
    mapping(address=>distributor) distributors;
    mapping(address=>wholesaler) wholesalers;
    mapping(address=>provider) providers;
    
    modifier onlyOwner{
      require(msg.sender == owner,
      "Sender not authorized."
      );
      _;
    }   
    
    constructor() public{
        owner=msg.sender;
    }
    
    function registerManufacturer(address m,string memory name, string memory adress) public onlyOwner{
        require(!manufacturers[m].existManufacturer,
        "Manufacturer exists already"
        );
        // manufacturers[m] = manufacturer(name,adress,true);
        manufacturers[m].existManufacturer = true;
        manufacturers[m].name = name;
        manufacturers[m].adress = adress;

    }
    
    function registerDistributor(address d,string memory name, string memory adress) public onlyOwner{
        require(!distributors[d].existDistributor,
        "Distributor exists already"
        );
        
        distributors[d].existDistributor = true;
        distributors[d].name = name;
        distributors[d].adress = adress;
    }
    
    function registerWholeSaler(address w,string memory name, string memory adress) public onlyOwner{
        require(!wholesalers[w].existWholesaler ,
        "WholeSaler exists already"
        );
        
        wholesalers[w].existWholesaler = true;
        wholesalers[w].name = name;
        wholesalers[w].adress = adress;

    }
    
    function registerProvider(address p, string memory name, string memory adress) public onlyOwner{
        require(!providers[p].existProvider,
        "Provider exists already"
        );
        
        providers[p].existProvider = true;
        providers[p].name = name;
        providers[p].adress = adress;
    }
    
    function isOwner(address o) public view returns(bool){
        return (owner==o);
    }
    
    function manufacturerExists(address m) public view returns(bool){
        return manufacturers[m].existManufacturer ;
    }
    
    function distributorExists(address d) public view returns(bool){
        return distributors[d].existDistributor;
    }
    
    function wholesalerExists(address w) public view returns(bool){
        return wholesalers[w].existWholesaler;
    }
    
    function providerExists(address p) public view returns(bool){
        return providers[p].existProvider;
    }
    
}

contract FabLot{

    address payable sender;
    struct Lot{
        address productID;
        string productName;
        string materialHash;
        string batchNumber;
        string CECertificateHash;
        uint totalQuantity;
        uint remainingQuantity;
        address registrationContract;
        string ownerType;
        address owner;
        Registration RegistrationContract;
    }

    Lot lot;

    event LotDispatched (address productID, string productName, string materialHash, string batchNumber, string CECertificateHash);
    event OwnershipTransferred (address NewOwner, string ownerType);
    event SaletToProvider (address productID, address providerAddress, uint quantitySold);
    
    modifier onlyOwner{
      require(msg.sender == lot.owner,
      "Sender not authorized."
      );
      _;
    }   
    

    modifier onlyWholeSaler{
      require(lot.RegistrationContract.wholesalerExists(msg.sender),
      "Sender not authorized."
      );
      _;
    }   

    modifier onlyManufacturer{
        require(lot.RegistrationContract.manufacturerExists(sender),
        "deployer not authorized.");
        _;
    }
    
    constructor(address registration) public payable{
        sender = msg.sender;
        lot.registrationContract=registration;
        
    }

    function CreateLot(address ID, string memory name, string memory material, string memory batch, string memory CE, uint quantity) public onlyManufacturer{
        
        lot.owner=sender;
        lot.productID=ID;
        lot.productName=name;
        lot.materialHash=material;
        lot.batchNumber=batch;
        lot.CECertificateHash=CE;
        lot.totalQuantity=quantity;
        lot.remainingQuantity=quantity;
        
        emit LotDispatched(address(this), name, material, batch, CE);
    }
    
    function transferOwnership (address payable newOwner) public onlyOwner{
        if(lot.RegistrationContract.manufacturerExists(newOwner))
        lot.ownerType="Manufacturer";
        else if(lot.RegistrationContract.distributorExists(newOwner))
        lot.ownerType="Distributor";
        else if(lot.RegistrationContract.wholesalerExists(newOwner))
        lot.ownerType="WholeSaler";
        else if(lot.RegistrationContract.providerExists(newOwner))
        lot.ownerType="Provider";
        else
        revert("New Owner doesn't exist.");
        lot.owner=newOwner;
        emit OwnershipTransferred(lot.owner,lot.ownerType);
    }
    
    function sellToProvider(address provider, uint quantityToSell) public onlyWholeSaler{
        require(lot.remainingQuantity>=quantityToSell,
        "Not enough Items available"
        );
        require(lot.RegistrationContract.providerExists(provider),
        "Provider does not exist"
        );
        
        lot.remainingQuantity-=quantityToSell;
        
        emit SaletToProvider(address(this),provider,quantityToSell);
        
        if(lot.remainingQuantity==0)
        {
            address payable owner1 = address(uint160(lot.owner));
            selfdestruct(owner1);

        }
    } 

}
